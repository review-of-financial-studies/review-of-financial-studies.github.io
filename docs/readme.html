<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>README Checker – RFS Data Editors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-f245066ca199b7326ac6b360085ddf3a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="assets/css/styles.css">
<link rel="stylesheet" href="assets/css/readme.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">RFS Data Editors</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./faqs.html"> 
<span class="menu-text">FAQs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./readme.html" aria-current="page"> 
<span class="menu-text">README Checker</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./license.html"> 
<span class="menu-text">License</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">README Checker</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="readme-checker">
  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  <p class="progress-text"><span id="answeredCount">0</span> of <span id="totalCount">0</span> items addressed</p>

  <main id="checklist"></main>

  <div class="summary" id="summary">
    <h3 class="anchored">Completeness Summary</h3>
    <div class="summary-stats">
      <div class="stat">
        <div class="stat-number" id="completePct">0%</div>
        <div class="stat-label">Complete</div>
      </div>
      <div class="stat">
        <div class="stat-number" id="answeredStat">0</div>
        <div class="stat-label">Items Checked</div>
      </div>
      <div class="stat">
        <div class="stat-number" id="remainingStat">0</div>
        <div class="stat-label">Remaining</div>
      </div>
    </div>
    <div id="summaryMessage"></div>
  </div>

  <footer class="checker-footer">
    <p>Template adapted from the <a href="https://social-science-data-editors.github.io/template_README/" target="_blank" rel="noopener">Social Science Data Editors' README template</a></p>
  </footer>
</div>

<script>
  const checklistData = [
    {
      title: "Title and Overview",
      questions: [
        {
          text: "Does your README include the exact title of the paper and author names?",
          example: `README for "Minimum Wages and Employment Dynamics"
Authors: Jane Doe (University of Example), John Smith (Research Institute)`
        },
        {
          text: "Does your README provide a short overview paragraph describing what the package contains and how to proceed?",
          example: `This replication package contains code and data required to reproduce all tables and figures in the paper. The workflow consists of (i) downloading and cleaning raw data from public sources, (ii) constructing the final analysis dataset, and (iii) running estimation routines that generate the results. All steps can be executed by running the main script programs/main.do. Total runtime is approximately 2 hours.`
        }
      ]
    },
    {
      title: "Data Availability and Provenance",
      questions: [
        {
          text: "Does your README state whether the paper uses external (non-simulated) data?",
          example: `This paper involves analysis of external data.

<span class="or-divider">— or —</span>

This paper does not involve analysis of external data; all data are simulated within the provided code.

<span class="or-divider">— or —</span>

All data are publicly available and downloaded automatically by the replication code.`
        },
        {
          text: "Does your README include a statement certifying the authors have rights to use the data?",
          example: `I certify that the author(s) of the manuscript have legitimate access to and permission to use the data used in this manuscript.

<span class="or-divider">— or —</span>

I certify that the author(s) of the manuscript have documented permission to redistribute/publish the data contained within this replication package.`
        },
        {
          text: "Does your README specify what license governs the data?",
          example: `The data are distributed under a Creative Commons Attribution 4.0 (CC-BY 4.0) license. See LICENSE.txt for details.`
        },
        {
          text: "Does your README state the overall public availability status of the data?",
          example: `All data are publicly available.

<span class="or-divider">— or —</span>

Some data cannot be made publicly available due to confidentiality / licensing restrictions.

<span class="or-divider">— or —</span>

All data are included in the replication package.`
        }
      ]
    },
    {
      title: "Data Source Details",
      questions: [
        {
          text: "For each data source, does your README document: source, format, access method, and whether it's included?",
          example: `The unemployment rate data is downloaded from the Federal Reserve Economic Data (FRED) database maintained by the Federal Reserve Bank of St. Louis.

Data source: Federal Reserve Bank of St. Louis, FRED
Series ID: UNRATE
URL: https://fred.stlouisfed.org/series/UNRATE
Access: Public use, no registration required
Format: CSV
License: Public domain (U.S. government data)
Download method: The code automatically downloads the data via the URL
Provided: Yes`
        },
        {
          text: "Does your README include a summary table of all datasets?",
          example: `| Dataset | Source | Format | Provided | License |
|---------|--------|--------|----------|---------|
| UNRATE | FRED | CSV | Yes | Public domain |
| CPS | Census | Stata | No | Restricted |`
        },
        {
          text: "Does your README indicate whether a data dictionary or codebook is provided, and where?",
          example: `Variable labels are included in the pseudo-data .dta files.

<span class="or-divider">— or —</span>

A full codebook that describes each variable and table is provided in codebook.xlsx.`
        }
      ]
    },
    {
      title: "Computational Requirements",
      questions: [
        {
          text: "Does your README list all required software and versions?",
          example: `The code was last run using Stata 18 MP. The required user-written packages are estout and reghdfe, both included in the ado directory.

<span class="or-divider">— or —</span>

Software: Python 3.11, R 4.3.0
Python packages: pandas 2.0.0, numpy 1.24.0, statsmodels 0.14.0
R packages: tidyverse 2.0.0, fixest 0.11.0`
        },
        {
          text: "Does your README describe how to install dependencies (setup script or instructions)?",
          example: `The replication package includes setup.do, which installs all required packages and creates the necessary directory structure.

<span class="or-divider">— or —</span>

Various Python packages recorded in the pyproject.toml and uv.lock. By running uv sync, the required packages and their versions are installed.`
        },
        {
          text: "Does your README address random number generation and seed setting?",
          example: `Random seed is set at line 12 of program programs/config.do

<span class="or-divider">— or —</span>

The analysis relies on random number generation, but setting a seed is not possible.

<span class="or-divider">— or —</span>

No pseudo-random number generator is used in the analysis.`
        },
        {
          text: "Does your README provide an estimate of runtime?",
          example: `Approximate time needed to reproduce the analyses on a standard (2025) desktop machine: 10-60 minutes`
        },
        {
          text: "Does your README state the required disk space?",
          example: `Approximate storage space needed: 25 MB - 250 MB`
        },
        {
          text: "Does your README describe the machine on which the code was last run?",
          example: `The code was last run on a 4-core laptop running macOS 14 with 16GB RAM and approximately 50GB of free disk space.`
        }
      ]
    },
    {
      title: "Program Description",
      questions: [
        {
          text: "Does your README identify the main entry point for replication?",
          example: `Running programs/main.do executes all steps in the correct order.

<span class="or-divider">— or —</span>

To replicate all results, run: python main.py`
        },
        {
          text: "Does your README describe any ordering dependencies or special execution rules?",
          example: `Programs in 02_analysis must be run sequentially, as later scripts depend on outputs from earlier ones.

<span class="or-divider">— or —</span>

All scripts are independent and can be run in any order after the data preparation step.`
        },
        {
          text: "Does your README specify the license for the code?",
          example: `The code is licensed under the MIT License. See LICENSE.txt for details.`
        }
      ]
    },
    {
      title: "Replication Instructions",
      questions: [
        {
          text: "Does your README provide step-by-step instructions for replicators?",
          example: `1. Ensure you have Python 3.13 installed
2. Ensure you have uv installed
3. Run uv sync to install dependencies
4. Ensure you have an active internet connection
5. Run uv run python main.py`
        },
        {
          text: "Does your README note any manual or non-automated steps?",
          example: `No manual steps are required; all procedures are fully automated.

<span class="or-divider">— or —</span>

Figure 1 must be generated manually using Excel following the instructions below.`
        }
      ]
    },
    {
      title: "Output Mapping",
      questions: [
        {
          text: "Does your README state which tables and figures are reproduced by the code?",
          example: `All tables and figures in the main paper.

<span class="or-divider">— or —</span>

All tables and figures in the paper and online appendix.`
        },
        {
          text: "Does your README include a mapping of outputs to programs?",
          example: `| Output | Program | Output file |
|--------|---------|-------------|
| Table 1 | 02_analysis/table1.do | results/table1.tex |
| Figure 1 | 02_analysis/figure1.R | figures/figure1.pdf |
| Table A1 | 03_appendix/tableA1.do | results/tableA1.tex |`
        }
      ]
    },
    {
      title: "References and Acknowledgements",
      questions: [
        {
          text: "Does your README include formal citations for all datasets used?",
          example: `Federal Reserve Bank of St. Louis. "Unemployment Rate [UNRATE]." FRED, Federal Reserve Bank of St. Louis. https://fred.stlouisfed.org/series/UNRATE (accessed January 15, 2025).`
        },
        {
          text: "Does your README acknowledge any templates or external materials used?",
          example: `This README template was adapted from the Social Science Data Editors' README template, available at https://social-science-data-editors.github.io/template_README/`
        }
      ]
    }
  ];

  let totalQuestions = 0;
  let answeredQuestions = 0;

  function init() {
    const container = document.getElementById('checklist');
    
    checklistData.forEach((section, sIdx) => {
      const sectionEl = document.createElement('div');
      sectionEl.className = 'section';
      sectionEl.innerHTML = `
        <div class="section-header" data-section="${sIdx}">
          <span class="section-number" id="sectionNum${sIdx}">${sIdx + 1}</span>
          <h2>${section.title}</h2>
        </div>
        <div class="section-content" id="sectionContent${sIdx}"></div>
      `;
      container.appendChild(sectionEl);

      const contentEl = document.getElementById(`sectionContent${sIdx}`);
      
      section.questions.forEach((q, qIdx) => {
        totalQuestions++;
        const qId = `q${sIdx}_${qIdx}`;
        
        const questionEl = document.createElement('div');
        questionEl.className = 'question';
        questionEl.id = qId;
        questionEl.innerHTML = `
          <div class="question-text">${q.text}</div>
          <div class="checkbox-group">
            <label class="checkbox-label">
              <input type="checkbox" data-section="${sIdx}" data-question="${qIdx}" onchange="updateProgress()">
              <span>Yes, my README includes this</span>
            </label>
          </div>
          <button class="example-toggle" onclick="toggleExample('${qId}')">
            <span class="arrow">▶</span> Show best practice example
          </button>
          <div class="example-content" id="${qId}_example">
            <h4>Example</h4>
            <pre>${q.example}</pre>
          </div>
        `;
        contentEl.appendChild(questionEl);
      });
    });

    document.getElementById('totalCount').textContent = totalQuestions;
    updateProgress();
  }

  function toggleExample(qId) {
    const exampleEl = document.getElementById(`${qId}_example`);
    const toggleBtn = exampleEl.previousElementSibling;
    
    exampleEl.classList.toggle('visible');
    toggleBtn.classList.toggle('open');
    
    if (exampleEl.classList.contains('visible')) {
      toggleBtn.innerHTML = '<span class="arrow">▶</span> Hide example';
    } else {
      toggleBtn.innerHTML = '<span class="arrow">▶</span> Show best practice example';
    }
  }

  function updateProgress() {
    const checkboxes = document.querySelectorAll('.readme-checker input[type="checkbox"]');
    answeredQuestions = 0;
    const sectionCounts = {};

    checkboxes.forEach(cb => {
      const section = cb.dataset.section;
      if (!sectionCounts[section]) {
        sectionCounts[section] = { total: 0, checked: 0 };
      }
      sectionCounts[section].total++;
      
      if (cb.checked) {
        answeredQuestions++;
        sectionCounts[section].checked++;
      }

      const questionEl = cb.closest('.question');
      if (cb.checked) {
        questionEl.classList.add('answered');
      } else {
        questionEl.classList.remove('answered');
      }
    });

    // Update section indicators
    Object.keys(sectionCounts).forEach(sIdx => {
      const numEl = document.getElementById(`sectionNum${sIdx}`);
      if (sectionCounts[sIdx].checked === sectionCounts[sIdx].total) {
        numEl.classList.add('complete');
      } else {
        numEl.classList.remove('complete');
      }
    });

    // Update progress bar
    const pct = Math.round((answeredQuestions / totalQuestions) * 100);
    document.getElementById('progressFill').style.width = `${pct}%`;
    document.getElementById('answeredCount').textContent = answeredQuestions;
    
    // Update summary
    document.getElementById('completePct').textContent = `${pct}%`;
    document.getElementById('answeredStat').textContent = answeredQuestions;
    document.getElementById('remainingStat').textContent = totalQuestions - answeredQuestions;

    // Generate missing items list
    const messageEl = document.getElementById('summaryMessage');
    if (answeredQuestions === totalQuestions) {
      messageEl.innerHTML = '<div class="complete-message">✓ Your README addresses all recommended elements. Well done!</div>';
    } else {
      const missing = [];
      checkboxes.forEach(cb => {
        if (!cb.checked) {
          const questionText = cb.closest('.question').querySelector('.question-text').textContent;
          missing.push(questionText);
        }
      });
      
      messageEl.innerHTML = `
        <div class="missing-list">
          <h4>Items not yet addressed:</h4>
          <ul>
            ${missing.slice(0, 5).map(m => `<li>${m}</li>`).join('')}
            ${missing.length > 5 ? `<li><em>...and ${missing.length - 5} more</em></li>` : ''}
          </ul>
        </div>
      `;
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>